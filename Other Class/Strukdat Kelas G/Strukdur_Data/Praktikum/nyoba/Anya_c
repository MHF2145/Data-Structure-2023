#include <stdio.h>
#include <math.h>
#include <stdlib.h>

define LL long long
define ULL unsigned long long
define PI 3.141592653589793238462643383279502884197169399375105820974944592307816406286
typedef struct dynamicarr_t { int *_arr; int _size, _capacity; } DynamicArray;

void dArray_init(DynamicArray darray) { darray->_capacity = 2u; darray->_size = 0u; darray->_arr = (int) malloc(sizeof(int) * 2); }

void dArray_pushBack(DynamicArray *darray, int value) { if (darray->_size + 1 > darray->_capacity) { int it; darray->_capacity *= 2; int newArr = (int) malloc(sizeof(int) * darray->_capacity);

    for (it=0; it < darray->_size; ++it)
        newArr[it] = darray->_arr[it];

    int *oldArray = darray->_arr;
    darray->_arr = newArr;
    free(oldArray);
}
darray->_arr[darray->_size++] = value;
}

bool dArray_isEmpty(DynamicArray *darray) { return (darray->_size == 0); }

int dArray_getAt(DynamicArray *darray, int index){ if(index >= darray->_size) return darray->_arr[darray->_size-1]; return darray->_arr[index]; }

void yuju(DynamicArray *darray, int index, int value){ darray->_arr[index] += value; // return darray->_arr[index]; }

/** * Node structure and * uniqueBST structure */

typedef struct bstnode_t { int key; struct bstnode_t \ *left, *right; } BSTNode;

typedef struct bst_t { BSTNode *_root; unsigned int _size; } BST;

/** * !!! WARNING UTILITY FUNCTION !!! * Recognized by prefix "bst" * --------------------------------------------- * Note that you better never access these functions, * unless you need to modify or you know how these functions work. */

BSTNode* __bst__createNode(int value) { BSTNode newNode = (BSTNode) malloc(sizeof(BSTNode)); newNode->key = value; newNode->left = newNode->right = NULL; return newNode; }

BSTNode* __bst__insert(BSTNode *root, int value) { if (root == NULL) return __bst__createNode(value);

if (value < root->key)
    root->left = __bst__insert(root->left, value);
else if (value > root->key)
    root->right = __bst__insert(root->right, value);

return root;
}

BSTNode* __bst__search(BSTNode *root, int value) { while (root != NULL) { if (value < root->key) root = root->left; else if (value > root->key) root = root->right; else return root; } return root; }

BSTNode* __bst__findMinNode(BSTNode *node) { BSTNode *currNode = node; while (currNode && currNode->left != NULL) currNode = currNode->left;

return currNode;
}

BSTNode* __bst__remove(BSTNode *root, int value) { if (root == NULL) return NULL;

if (value > root->key) 
    root->right = __bst__remove(root->right, value);
else if (value < root->key) 
    root->left = __bst__remove(root->left, value);
else {

    if (root->left == NULL) {
        BSTNode *rightChild = root->right;
        free(root);
        return rightChild;
    }
    else if (root->right == NULL) {
        BSTNode *leftChild = root->left;
        free(root);
        return leftChild;
    }

    BSTNode *temp = __bst__findMinNode(root->right);
    root->key     = temp->key;
    root->right   = __bst__remove(root->right, temp->key);
}
return root;
}

void __bst__inorder(BSTNode *root) { if (root) { __bst__inorder(root->left); printf("%d ", root->key); __bst__inorder(root->right); } }

void __bst__postorder(BSTNode *root) { if (root) { __bst__postorder(root->left); __bst__postorder(root->right); printf("%d ", root->key); } }

void __bst__preorder(BSTNode *root) { if (root) { printf("%d ", root->key); __bst__preorder(root->left); __bst__preorder(root->right); } }

/** * PRIMARY FUNCTION * --------------------------- * Accessible and safe to use. */

void bst_init(BST *bst) { bst->_root = NULL; bst->_size = 0u; }

bool bst_isEmpty(BST *bst) { return bst->_root == NULL; }

bool bst_find(BST *bst, int value) { BSTNode *temp = __bst__search(bst->_root, value); if (temp == NULL) return false;

if (temp->key == value)
    return true;
else
    return false;
}

void bst_insert(BST *bst, int value) { if (!bst_find(bst, value)) { bst->_root = __bst__insert(bst->_root, value); bst->_size++; } }

void bst_remove(BST *bst, int value) { if (bst_find(bst, value)) { bst->_root = __bst__remove(bst->_root, value); bst->_size--; } }

/** * Binary search tree traversal * - Inorder * - Postorder * - Preorder */

void bst_inorder(BST *bst) { __bst__inorder(bst->_root); }

void bst_postorder(BST *bst) { __bst__postorder(bst->_root); }

void bst_preorder(BST *bst) { __bst__preorder(bst->_root); }

typedef struct AVLNode_t { int data; struct AVLNode_t *left,*right; int height; }AVLNode;

typedef struct AVL_t { AVLNode *_root; unsigned int _size; }AVL;

AVLNode* _avl_createNode(int value) { AVLNode newNode = (AVLNode) malloc(sizeof(AVLNode)); newNode->data = value; newNode->height=1; newNode->left = newNode->right = NULL; return newNode; }

AVLNode* _search(AVLNode *root, int value) { while (root != NULL) { if (value < root->data) root = root->left; else if (value > root->data) root = root->right; else return root; } return root; }

int _getHeight(AVLNode* node){ if(node==NULL) return 0; return node->height; }

int _max(int a,int b){ return (a > b)? a : b; }

AVLNode* _rightRotate(AVLNode* pivotNode) {

AVLNode* newParrent=pivotNode->left;
pivotNode->left=newParrent->right;
newParrent->right=pivotNode;

pivotNode->height=_max(_getHeight(pivotNode->left),
                  _getHeight(pivotNode->right))+1;
newParrent->height=_max(_getHeight(newParrent->left),
                   _getHeight(newParrent->right))+1;

return newParrent;
}

AVLNode* _leftRotate(AVLNode* pivotNode) {

AVLNode* newParrent=pivotNode->right;
pivotNode->right=newParrent->left;
newParrent->left=pivotNode;

pivotNode->height=_max(_getHeight(pivotNode->left),
                  _getHeight(pivotNode->right))+1;
newParrent->height=_max(_getHeight(newParrent->left),
                   _getHeight(newParrent->right))+1;

return newParrent;
}

AVLNode* _leftCaseRotate(AVLNode* node){ return _rightRotate(node); }

AVLNode* _rightCaseRotate(AVLNode* node){ return _leftRotate(node); }

AVLNode* _leftRightCaseRotate(AVLNode* node){ node->left=_leftRotate(node->left); return _rightRotate(node); }

AVLNode* _rightLeftCaseRotate(AVLNode* node){ node->right=_rightRotate(node->right); return _leftRotate(node); }

int _getBalanceFactor(AVLNode* node){ if(node==NULL) return 0; return _getHeight(node->left)-_getHeight(node->right); }

AVLNode* _insert_AVL(AVL avl,AVLNode node,int value) {

if(node==NULL) // udah mencapai leaf
    return _avl_createNode(value);
if(value < node->data)
    node->left = _insert_AVL(avl,node->left,value);
else if(value > node->data)
    node->right = _insert_AVL(avl,node->right,value);

node->height= 1 + _max(_getHeight(node->left),_getHeight(node->right)); 

int balanceFactor=_getBalanceFactor(node);

if(balanceFactor > 1 && value < node->left->data) // skewed kiri (left-left case)
    return _leftCaseRotate(node);
if(balanceFactor > 1 && value > node->left->data) // 
    return _leftRightCaseRotate(node);
if(balanceFactor < -1 && value > node->right->data)
    return _rightCaseRotate(node);
if(balanceFactor < -1 && value < node->right->data)
    return _rightLeftCaseRotate(node);

return node;
}

AVLNode* _findMinNode(AVLNode *node) { AVLNode *currNode = node; while (currNode && currNode->left != NULL) currNode = currNode->left; return currNode; }

AVLNode* _remove_AVL(AVLNode* node,int value){ if(node==NULL) return node; if(value > node->data) node->right=_remove_AVL(node->right,value); else if(value < node->data) node->left=_remove_AVL(node->left,value); else{ AVLNode *temp; if((node->left==NULL)||(node->right==NULL)){ temp=NULL; if(node->left==NULL) temp=node->right;
else if(node->right==NULL) temp=node->left;

        if(temp==NULL){
            temp=node;
            node=NULL;
        }
        else
            *node=*temp;   

        free(temp);
    }
    else{
        temp = _findMinNode(node->right);
        node->data=temp->data;
        node->right=_remove_AVL(node->right,temp->data);
    }    
}

if(node==NULL) return node;

node->height=_max(_getHeight(node->left),_getHeight(node->right))+1;

int balanceFactor= _getBalanceFactor(node);

if(balanceFactor>1 && _getBalanceFactor(node->left)>=0) 
    return _leftCaseRotate(node);

if(balanceFactor>1 && _getBalanceFactor(node->left)<0) 
    return _leftRightCaseRotate(node);

if(balanceFactor < -1 && _getBalanceFactor(node->right)<=0) 
    return _rightCaseRotate(node);

if(balanceFactor < -1 && _getBalanceFactor(node->right)>0) 
    return _rightLeftCaseRotate(node);

return node;
}

void avl_init(AVL *avl) { avl->_root = NULL; avl->_size = 0u; }

bool avl_isEmpty(AVL *avl) { return avl->_root == NULL; }

bool avl_find(AVL *avl, int value) { AVLNode *temp = _search(avl->_root, value); if (temp == NULL) return false;

if (temp->data == value)
    return true;
else
    return false;
}

void avl_insert(AVL *avl,int value){ if(!avl_find(avl,value)){ avl->_root=_insert_AVL(avl,avl->_root,value); avl->_size++; }

}

void avl_remove(AVL *avl,int value){ if(avl_find(avl,value)){ avl->_root=_remove_AVL(avl->_root,value); avl->_size--; }

}

void preorder(AVLNode *root) { if (root) { preorder(root->left); printf("%d ", root->data); preorder(root->right); } }

int mylovelyroot; void eunha(DynamicArray *darray, BSTNode *root){ if(root){ eunha(darray, root->left); BSTNode *temp1 = root->left; BSTNode *temp2 = root->right; if((temp1 != NULL || temp2 != NULL) && root->key != mylovelyroot) dArray_pushBack(darray, root->key); eunha(darray, root->right); } }

void weselia(DynamicArray *darray, AVLNode *root){ if(root){ weselia(darray, root->left); AVLNode *temp1 = root->left; AVLNode *temp2 = root->right; if(temp1 == NULL && temp2 == NULL) dArray_pushBack(darray, root->data); weselia(darray, root->right); } }

int main(){ BST set; bst_init(&set); DynamicArray myArray; dArray_init(&myArray); char una[105]; int n, m, idx = 0, syr; scanf("%d%d", &n, &m);

while(m--){
    scanf("%s", una);
    syr = 0; // jumlah beruntuun
    int len = n, i = 0;
    int mult = una[n] - '0'; //pengali
    for(; i < n; i++){
        if(una[i] != 'X'){
            syr += una[i] - 64;
            dArray_pushBack(&myArray, syr * mult);
// printf("uwu : %d\n", syr * mult); idx++; } } } // end bagian ambil node

int i = 0;
for(; i < idx; i++) bst_insert(&set, dArray_getAt(&myArray, i));
// end ngisi bst
// bst_inorder(&set); // puts("");

AVL hamin;
avl_init(&hamin); //ambil bagian masuk syarat jadi avl anyar
DynamicArray sheera;
dArray_init(&sheera);
BSTNode *temp = set._root;
mylovelyroot = temp->key;
// printf("rootku = %d\n", mylovelyroot); eunha(&sheera, temp); i = 0; // printf("Here : "); // for(; i < sheera._size; i++) printf("%d ", dArray_getAt(&sheera, i)); // printf("\n"); i = 0; for(; i < sheera._size; i++) avl_insert(&hamin, dArray_getAt(&sheera, i)); // end ambil masuk syarat

//cetak hasil akhir
AVLNode *cristela = hamin._root;
DynamicArray galeu;
dArray_init(&galeu);
weselia(&galeu, cristela);
if(dArray_isEmpty(&galeu)) printf("Punten, inputnya kurang :D\n");
else{
    int even = 0, odd = 0;
    i = 0;
    for(; i < galeu._size; i++){
        if(dArray_getAt(&galeu, i) & 1) odd++;
        else even++;
    }
    if(even && odd) printf("PEANUT");
    else if(even) printf("Sssttsecret");
    else printf("Missionn?");
    i = 0;
    for(; i < galeu._size; i++) printf("%d", dArray_getAt(&galeu, i));
    printf(".avl\n");
} // end yayyy

return 0;
}